---
import Layout from '../layouts/Layout.astro';
import Navbar from '../components/Navbar.astro';
import Footer from '../components/Footer.astro';
---

<Layout title="ez co | building easier">
	<!-- Grid background -->
	<div class="grid-background"></div>

	<section
		class="w-[min(80ch,100vw)] min-h-screen mt-[6rem] md:mt-[8rem] flex items-start justify-center px-4 md:px-6 lg:px-8 relative z-10"
	>
		<div class="w-full mx-auto flex flex-col gap-6 md:gap-8">
			<Navbar currentPath="/" />
			<div class="text-container">
				<h1
					class="text-4xl sm:text-5xl md:text-6xl lg:text-7xl font-light text-[#F5F5F5] md:mb-8 main-text"
					style="font-family: Times; line-height: 1.2; letter-spacing: -0.02em;"
					id="main-heading"
				>
					<br />
					build{' '}
					<span
						class="inline-block font-bold relative text-[#F5F5F5]"
						id="dynamic-text"
					>
						<span class="inline-block" id="text-content">{''}</span>
						<span
							class="absolute top-0 ml-[2px] md:ml-[4px] w-[1.5px] md:w-[2px] h-[1em] bg-[#F5F5F5] animate-blink"
							id="cursor"></span>
					</span>
				</h1>
				<!-- Water reflection -->
				<div class="water-reflection" id="water-reflection">
					<h1
						class="text-4xl sm:text-5xl md:text-6xl lg:text-7xl font-light text-[#F5F5F5] reflection-text"
						style="font-family: Times; line-height: 1.2; letter-spacing: -0.02em; transform: translate(0, 1rem);"
						id="reflection-heading"
					>
						build{' '}
						<span
							class="inline-block font-bold relative text-[#F5F5F5]"
							id="dynamic-text-reflection"
						>
							<span
								class="inline-block"
								id="text-content-reflection">{''}</span
							>
							<span
								class="absolute top-0 ml-[2px] md:ml-[4px] w-[1.5px] md:w-[2px] h-[1em] bg-[#F5F5F5] animate-blink"
								id="cursor-reflection"></span>
						</span>
					</h1>
				</div>
			</div>
			<p
				class="text-lg sm:text-xl md:text-2xl text-[#F5F5F5] max-w-2xl mb-8 md:mb-12"
				style="font-family: Times;"
			>
				For those seeking simple, open, user-friendly solutions.
			</p>
			<div class="flex flex-col sm:flex-row gap-3 md:gap-4">
				<a
					href="/newproject"
					class="inline-block bg-[#F5F5F5] text-black px-6 md:px-8 py-3 md:py-4 text-base md:text-lg transition-all duration-300 hover:bg-opacity-90 text-center sm:text-left"
				>
					Start a project
				</a>
				<a
					href="/work"
					class="inline-block border border-[#F5F5F5] text-[#F5F5F5] px-6 md:px-8 py-3 md:py-4 text-base md:text-lg transition-all duration-300 hover:bg-[#F5F5F5] hover:text-black text-center sm:text-left"
				>
					View our work
				</a>
			</div>
		</div>
	</section>

	<Footer slot="footer" />
</Layout>

<style>
	/* Grid background */
	.grid-background {
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 1;
		opacity: 0;
		background-image: linear-gradient(
				rgba(245, 245, 245, 0.2) 1px,
				transparent 1px
			),
			linear-gradient(
				90deg,
				rgba(245, 245, 245, 0.2) 1px,
				transparent 1px
			),
			linear-gradient(rgba(245, 245, 245, 0.05) 1px, transparent 1px),
			linear-gradient(
				90deg,
				rgba(245, 245, 245, 0.05) 1px,
				transparent 1px
			);
		background-size:
			100px 100px,
			100px 100px,
			20px 20px,
			20px 20px;
		pointer-events: none;
	}

	/* Text container for positioning */
	.text-container {
		position: relative;
		z-index: 10;
	}

	/* Main text styling */
	.main-text {
		position: relative;
		z-index: 10;
	}

	/* Water reflection container */
	.water-reflection {
		top: 100%;
		left: 0;
		width: 100%;
		overflow: hidden;
		transform: scaleY(-1);
		opacity: 0.1;
		background: linear-gradient(
			to bottom,
			rgba(0, 0, 0, 0) 0%,
			rgba(0, 0, 0, 0.1) 10%,
			rgba(0, 0, 0, 0.4) 40%,
			rgba(0, 0, 0, 0.7) 70%,
			rgba(0, 0, 0, 0.95) 100%
		);
		mask: linear-gradient(
			to bottom,
			rgba(255, 255, 255, 0) 0.1%,
			rgba(255, 255, 255, 1) 100%
		);
		/* -webkit-mask: linear-gradient(
			to bottom,
			rgba(255, 255, 255, 0.7) 0%,
			rgba(255, 255, 255, 0.5) 20%,
			rgba(255, 255, 255, 0.3) 50%,
			rgba(255, 255, 255, 0.1) 80%,
			rgba(255, 255, 255, 0) 100%
		); */
		pointer-events: none;
	}

	/* Reflection text */
	.reflection-text {
		filter: blur(1px);
	}

	/* Enhanced grid with perspective */
	.grid-background::before {
		content: '';
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		background-image: linear-gradient(
				rgba(245, 245, 245, 0.05) 1px,
				transparent 1px
			),
			linear-gradient(
				90deg,
				rgba(245, 245, 245, 0.05) 1px,
				transparent 1px
			);
		background-size: 20px 20px;
		transform: perspective(500px) rotateX(60deg);
		transform-origin: bottom;
	}
</style>

<script>
	// Dynamic text animation with water effects
	const words = ['easier', 'smarter', 'minimal', 'in the open', 'the future'];
	let currentIndex = 0;

	const dynamicTextElement = document.getElementById(
		'dynamic-text',
	) as HTMLElement | null;
	const textSpan = document.getElementById(
		'text-content',
	) as HTMLElement | null;
	const cursor = document.getElementById('cursor') as HTMLElement | null;

	// Reflection elements
	const dynamicTextReflection = document.getElementById(
		'dynamic-text-reflection',
	) as HTMLElement | null;
	const textSpanReflection = document.getElementById(
		'text-content-reflection',
	) as HTMLElement | null;
	const cursorReflection = document.getElementById(
		'cursor-reflection',
	) as HTMLElement | null;

	if (
		textSpan &&
		cursor &&
		dynamicTextElement &&
		textSpanReflection &&
		cursorReflection &&
		dynamicTextReflection
	) {
		// Calculate the minimum width needed for the longest word to prevent layout shifts
		const longestWord = words.reduce((a, b) =>
			a.length > b.length ? a : b,
		);

		// Create invisible placeholder element to reserve space for longest word
		const placeholder = document.createElement('span');
		placeholder.style.visibility = 'hidden';
		placeholder.style.position = 'absolute';
		placeholder.style.pointerEvents = 'none';
		placeholder.style.fontSize = getComputedStyle(textSpan).fontSize;
		placeholder.style.fontFamily = getComputedStyle(textSpan).fontFamily;
		placeholder.style.fontWeight = getComputedStyle(textSpan).fontWeight;
		placeholder.textContent = longestWord;
		dynamicTextElement.appendChild(placeholder);

		// Function to update cursor position based on text content
		const updateCursorPosition = () => {
			if (textSpan && cursor) {
				const textWidth = textSpan.offsetWidth;
				cursor.style.left = `${textWidth}px`;
			}
			if (textSpanReflection && cursorReflection) {
				const textWidth = textSpanReflection.offsetWidth;
				cursorReflection.style.left = `${textWidth}px`;
			}
		};

		const typeWord = async (word: string) => {
			textSpan.textContent = '';
			textSpanReflection.textContent = '';
			updateCursorPosition();

			for (let i = 0; i < word.length; i++) {
				await new Promise((resolve) =>
					setTimeout(resolve, 10 + Math.random() * 100),
				);
				if (textSpan && textSpanReflection) {
					textSpan.textContent += word[i];
					textSpanReflection.textContent += word[i];
					updateCursorPosition();
				}
			}
		};

		const clearWord = async () => {
			if (
				dynamicTextElement &&
				cursor &&
				dynamicTextReflection &&
				cursorReflection
			) {
				dynamicTextElement.classList.add('bg-[#F5F5F5]', 'text-black');
				dynamicTextReflection.classList.add(
					'bg-[#F5F5F5]',
					'text-black',
				);
				cursor.style.display = 'none';
				cursorReflection.style.display = 'none';

				await new Promise((resolve) =>
					setTimeout(resolve, 300 + Math.random() * 100),
				);

				if (textSpan && textSpanReflection) {
					textSpan.textContent = '';
					textSpanReflection.textContent = '';
					updateCursorPosition();
				}
				dynamicTextElement.classList.remove(
					'bg-[#F5F5F5]',
					'text-black',
				);
				dynamicTextReflection.classList.remove(
					'bg-[#F5F5F5]',
					'text-black',
				);
				cursor.style.display = 'block';
				cursorReflection.style.display = 'block';
			}
		};

		const startAnimation = async () => {
			while (true) {
				const word = words[currentIndex];
				await typeWord(word);

				await new Promise((resolve) =>
					setTimeout(resolve, 2000 + Math.random() * 1000),
				);

				await clearWord();

				await new Promise((resolve) => setTimeout(resolve, 200));

				currentIndex = (currentIndex + 1) % words.length;
			}
		};

		// Start animation after page load
		setTimeout(startAnimation, 1000);
	}
</script>
