---
import Layout from "../layouts/Layout.astro";
import Footer from "../components/Footer.astro";
import Navbar from "../components/Navbar.astro";
import { readFileSync } from "fs";
import { fileURLToPath } from "url";
import { dirname, join } from "path";

// Read Packery script from public directory at build time
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const publicDir = join(__dirname, "../../public");
const packeryScript = readFileSync(join(publicDir, "packery.min.js"), "utf-8");

// Inline Packery script to avoid FOUC, sure would be nice if browser supported Masonry grid natively
const packeryLoad =
	"<script type='module'>" + packeryScript + ";window.PackeryInit()</script>";
const projects = [
	{
		title: "markdown-editor",
		icon: "üìù",
		description:
			"An intuitive, minimal, extensible markdown editor component",
		tags: ["TipTap", "ProseMirror", "TypeScript"],
		link: "https://github.com/join-ezco/mono/tree/main/src/typescript/markdown-editor",
	},
	{
		title: "codeblock",
		icon: "üíª",
		description:
			"A codeblock component with language server and virtual filesystem support",
		tags: ["CodeMirror", "TypeScript"],
		link: "https://github.com/join-ezco/mono/tree/main/src/typescript/codeblock",
	},
	{
		title: "witmproxy",
		icon: "üåê",
		description: "A WASM-in-the-middle proxy",
		tags: ["Rust", "Plugins", "WASM", "mitmproxy"],
		link: "https://github.com/join-ezco/mono/tree/main/src/apps/witmproxy",
	},
];
---

<!-- Order is sequential, first we make the promise available to the window -->
<script is:inline>
	window.PackeryPromise = new Promise((resolve) => {
		window.PackeryInit = () => {
			resolve(window.Packery);
		};
	});
</script>
<!-- And then resolve it in our Fragment, which is our embedded Packery script -->
<Fragment set:html={packeryLoad} />
<!-- Then, as soon as our skeleton element is available, we use Packery to layout the skeleton -->
<script is:inline>
	function waitForElement(selector) {
		return new Promise((resolve) => {
			if (document.querySelector(selector)) {
				return resolve(document.querySelector(selector));
			}

			const observer = new MutationObserver((mutations) => {
				if (document.querySelector(selector)) {
					observer.disconnect();
					resolve(document.querySelector(selector));
				}
			});

			// If you get "parameter 1 is not of type 'Node'" error, see https://stackoverflow.com/a/77855838/492336
			observer.observe(document.documentElement, {
				childList: true,
				subtree: true,
			});
		});
	}

	waitForElement("#loading-skeleton").then(async (loadingSkeleton) => {
		await window.PackeryPromise;

		window.skeletonPackery = new window.Packery(loadingSkeleton, {
			itemSelector: ".grid-item",
			sizer: ".grid-sizer",
			gutter: 16,
			percentPosition: true,
		});
	});
</script>
<Layout title="Work | ez co" description="A showcase of projects we've built.">
	<section>
		<div class="w-full mx-auto flex flex-col gap-8">
			<Navbar currentPath="/work" />

			{/* Loading skeleton placeholders - using same grid structure */}
			<div id="loading-skeleton" class="opacity-100">
				<div class="grid-sizer"></div>

				{
					/* New Project skeleton - matches the actual new-project card */
				}
				<div class="grid-item skeleton-item">
					<div
						class="skeleton-card border-2 border-dashed border-[#666666] overflow-hidden"
					>
						<div class="p-6">
							<div class="flex items-center justify-between mb-3">
								<div class="skeleton-title"></div>
								<div class="skeleton-button"></div>
							</div>
							<div class="skeleton-description mb-4"></div>
							<div class="skeleton-description-line mb-4"></div>
							<div class="flex flex-wrap gap-2">
								<div class="skeleton-tag"></div>
							</div>
						</div>
					</div>
				</div>

				{/* Regular project skeletons */}
				{
					projects.map((_, index) => (
						<div class="grid-item skeleton-item">
							<div class="skeleton-card border-2 border-[#333333] overflow-hidden">
								<div class="p-6">
									<div class="flex items-center justify-between mb-3">
										<div class="skeleton-title" />
										<div class="skeleton-button" />
									</div>
									<div class="skeleton-description mb-4" />
									<div class="skeleton-description-line mb-4" />
									<div class="flex flex-wrap gap-2">
										<div class="skeleton-tag" />
										<div class="skeleton-tag" />
										<div class="skeleton-tag" />
									</div>
								</div>
							</div>
						</div>
					))
				}
			</div>

			{/* Packery Grid Container - positioned over skeleton */}
			<div
				id="grid-container"
				class="opacity-0 absolute top-0 left-0 w-full"
			>
				<div class="grid-sizer"></div>

				{/* New Project Action Card - First Item */}
				<div class="grid-item" data-project-title="new-project">
					<a href="/newproject" class="block w-full h-full">
						<div
							class="work-item-card new-project-card h-full hover:bg-[#ffffff] active:bg-[#ffffff] transition-all duration-300 overflow-hidden"
						>
							<div class="p-6">
								<div
									class="flex items-center justify-between mb-3"
								>
									<h3
										class="text-2xl font-bold text-[#F5F5F5] work-item-title"
									>
										[ your project here ]
									</h3>
									<span>‚ú®</span>
								</div>
								<p
									class="description-text text-[18px] text-[#F5F5F5] opacity-80 mb-4 work-item-description"
								>
									Want to see an idea come to life? See how we
									can help.
								</p>
								<div class="flex flex-wrap gap-2">
									<span
										class="px-2 py-1 text-xs rounded-full border border-[#333333] text-[#F5F5F5] opacity-70 work-item-tag"
									>
										Start a new project
									</span>
								</div>
							</div>
						</div>
					</a>
				</div>

				{
					projects.map((project) => (
						<div
							class="grid-item"
							data-project-title={project.title}
						>
							<div class="work-item-card h-full border-2 border-[#333333] hover:border-[#ffffff] hover:bg-[#ffffff] active:border-[#ffffff] active:bg-[#ffffff] transition-all duration-300 overflow-hidden">
								<div class="p-6">
									<div class="flex items-center justify-between mb-3">
										<h3 class="text-2xl font-bold text-[#F5F5F5] work-item-title flex items-center gap-3">
											{/* <span class="text-3xl">{project.icon}</span> */}
											{project.title}
										</h3>
										{/* Only show toggle button if project has a demo */}
										{(project.title === "markdown-editor" ||
											project.title === "codeblock") && (
											<button
												class="expand-toggle relative flex items-center justify-center w-6 h-6 text-[#F5F5F5] text-xl transition-transform duration-300"
												aria-label="Toggle project details"
											>
												<span class="toggle-icon absolute">
													+
												</span>
												<span class="loading-icon absolute hidden">
													<svg
														class="w-5 h-5"
														viewBox="0 0 24 24"
														fill="none"
														xmlns="http://www.w3.org/2000/svg"
													>
														<circle
															cx="12"
															cy="12"
															r="10"
															stroke="currentColor"
															stroke-width="2"
															stroke-opacity="0.3"
														/>
														<path
															d="M12 2a10 10 0 0 1 10 10"
															stroke="currentColor"
															stroke-width="2"
															stroke-linecap="round"
														/>
													</svg>
												</span>
											</button>
										)}
									</div>
									<p class="description-text text-[18px] text-[#F5F5F5] opacity-80 mb-4 work-item-description">
										{project.description}
									</p>
									<div class="flex flex-wrap gap-2">
										{project.tags.map((tech) => (
											<span class="px-2 py-1 text-xs rounded-full border border-[#333333] text-[#F5F5F5] opacity-70 work-item-tag">
												{tech}
											</span>
										))}
									</div>
									<div class="project-content hidden mt-6">
										<div class="project-demo-container min-h-[400px] border border-[#333333]" />
									</div>
								</div>
							</div>
						</div>
					))
				}
			</div>
		</div>
	</section>

	<Footer slot="footer" />

	<script>
		import { CodeblockFS } from "@joinezco/codeblock";
		import { files } from "./data/work.js";

		let pckry: any | null = null;
		let resizeObserver: ResizeObserver | null = null;

		let fs: any = null;
		let editor: any = null;

		let initPromise: Promise<void> | null = null;

		async function init() {
			if (initPromise) return initPromise;

			initPromise = (async () => {
				fs = await CodeblockFS.worker();
				await Promise.all(
					files.map(async ([path, content]) => {
						await fs.writeFile(path, content);
					}),
				);
			})();

			return initPromise;
		}
		// Initialize filesystem and demos
		init();

		const demos = {
			"markdown-editor": async (
				containerEl: HTMLElement,
				containerParent: HTMLElement,
			) => {
				try {
					const { createEditor } = await import(
						"@joinezco/markdown-editor"
					);
					// Ensure fs is initialized before using it
					await initPromise;

					editor = createEditor({
						element: containerEl,
						fs: {
							fs,
							filepath: "hello.md",
						},
					});
					editor.view.dom.setAttribute(
						"data-theme",
						containerParent.matches(":hover") ? "light" : "dark",
					);
					containerParent.addEventListener("mouseover", () => {
						editor.view.dom.setAttribute("data-theme", "light");
					});
					containerParent.addEventListener("mouseout", () => {
						editor.view.dom.setAttribute("data-theme", "dark");
					});
				} catch (error) {
					console.error("Failed to load markdown editor:", error);
					containerEl.innerHTML = `<div class="text-red-500">Failed to load editor (see console for log).</div>`;
				}
			},
			codeblock: async (
				containerEl: HTMLElement,
				containerParent: HTMLElement,
			) => {
				try {
					const { createCodeblock, SearchIndex } = await import(
						"@joinezco/codeblock"
					);

					// Ensure fs is initialized before using it
					await initPromise;

					const index = await SearchIndex.get(
						fs,
						".codeblock/index.json",
					);
					const codeblock = createCodeblock({
						parent: containerEl,
						fs,
						filepath: "example.ts",
						index,
						cwd: "/",
					});
					codeblock.dom.setAttribute(
						"data-theme",
						containerParent.matches(":hover") ? "light" : "dark",
					);
					containerParent.addEventListener("mouseover", () => {
						codeblock.dom.setAttribute("data-theme", "light");
					});
					containerParent.addEventListener("mouseout", () => {
						codeblock.dom.setAttribute("data-theme", "dark");
					});
				} catch (error) {
					console.error("Failed to load codeblock editor:", error);
					containerEl.innerHTML = `<div class="text-red-500">Failed to load editor (see console for log).</div>`;
				}
			},
		};

		function applyRainbowPatternBorder(
			element: HTMLElement,
			options: any = {},
		) {
			const {
				dashWidth = 12,
				dashGap = 6,
				strokeWidth = 2,
				rainbowSpeed = 4, // seconds for one full cycle
				dashSpeed = 8,
				hoverRainbowSpeed = rainbowSpeed * 0.2, // 3x faster on hover
				hoverDashSpeed = dashSpeed * 0.2, // 3x faster on hover
			} = options;

			const svgNS = "http://www.w3.org/2000/svg";
			let animations: SVGAnimateElement[] = []; // Store animation references

			if (getComputedStyle(element).position === "static") {
				element.style.position = "relative";
			}

			// Get element dimensions
			const updateBorder = () => {
				const rect = element.getBoundingClientRect();
				const width = rect.width;
				const height = rect.height;

				// Calculate total perimeter for dash alignment
				const perimeter = 2 * (width + height - 2 * strokeWidth);
				const dashPattern = dashWidth + dashGap;
				const numDashes = Math.floor(perimeter / dashPattern);
				const adjustedDashPattern = perimeter / numDashes;
				const adjustedDashWidth =
					(adjustedDashPattern * dashWidth) / dashPattern;
				const adjustedDashGap =
					(adjustedDashPattern * dashGap) / dashPattern;

				// Remove old SVG if it exists
				const oldSvg = element.querySelector(".rainbow-border-svg");
				if (oldSvg) oldSvg.remove();

				// Create SVG overlay - same size as element
				const svg = document.createElementNS(svgNS, "svg");
				svg.classList.add("rainbow-border-svg");
				svg.setAttribute("width", `${width}`);
				svg.setAttribute("height", `${height}`);
				svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
				svg.style.position = "absolute";
				svg.style.top = "0";
				svg.style.left = "0";
				svg.style.pointerEvents = "none";
				svg.style.zIndex = "1";
				element.appendChild(svg);

				// Create defs
				const defs = document.createElementNS(svgNS, "defs");

				// Create rainbow colors that will cycle
				const colors = [
					"#ff0000",
					"#ff8800",
					"#ffff00",
					"#00ff00",
					"#0088ff",
					"#8800ff",
				];
				const numColors = colors.length;

				// Create 4 separate gradients for each side
				const createGradient = (
					id: string,
					isHorizontal: boolean,
					length: number,
				) => {
					const gradient = document.createElementNS(
						svgNS,
						"linearGradient",
					);
					gradient.setAttribute("id", id);
					gradient.setAttribute("gradientUnits", "userSpaceOnUse");

					if (isHorizontal) {
						gradient.setAttribute("x1", "0");
						gradient.setAttribute("y1", "0");
						gradient.setAttribute("x2", `${length}`);
						gradient.setAttribute("y2", "0");
					} else {
						gradient.setAttribute("x1", "0");
						gradient.setAttribute("y1", "0");
						gradient.setAttribute("x2", "0");
						gradient.setAttribute("y2", `${length}`);
					}

					// Create color stops with animated colors for cycling rainbow effect
					const repetitions = 3;
					const totalStops = repetitions * numColors;

					for (let rep = 0; rep < repetitions; rep++) {
						for (let i = 0; i < numColors; i++) {
							const stop = document.createElementNS(
								svgNS,
								"stop",
							);
							const offset =
								((rep * numColors + i) / totalStops) * 100;
							stop.setAttribute("offset", `${offset}%`);
							stop.setAttribute("stop-color", colors[i]);

							// Create cycling color animation for each stop
							const colorAnimate = document.createElementNS(
								svgNS,
								"animate",
							);
							colorAnimate.setAttribute(
								"attributeName",
								"stop-color",
							);

							// Create color values by cycling through rainbow colors
							const animatedColors: string[] = [];
							for (let cycle = 0; cycle < numColors; cycle++) {
								const colorIndex = (i + cycle) % numColors;
								animatedColors.push(colors[colorIndex]);
							}
							animatedColors.push(colors[i]); // Complete the cycle

							colorAnimate.setAttribute(
								"values",
								animatedColors.join(";"),
							);
							colorAnimate.setAttribute(
								"dur",
								`${rainbowSpeed}s`,
							);
							colorAnimate.setAttribute(
								"repeatCount",
								"indefinite",
							);

							// Store animation reference for hover control
							animations.push(colorAnimate);

							stop.appendChild(colorAnimate);
							gradient.appendChild(stop);
						}
					}

					// Add final stop to complete the cycle
					const finalStop = document.createElementNS(svgNS, "stop");
					finalStop.setAttribute("offset", "100%");
					finalStop.setAttribute("stop-color", colors[0]);

					// Animate final stop color too
					const finalColorAnimate = document.createElementNS(
						svgNS,
						"animate",
					);
					finalColorAnimate.setAttribute(
						"attributeName",
						"stop-color",
					);
					const finalAnimatedColors: string[] = [];
					for (let cycle = 0; cycle < numColors; cycle++) {
						const colorIndex = cycle % numColors;
						finalAnimatedColors.push(colors[colorIndex]);
					}
					finalAnimatedColors.push(colors[0]); // Complete the cycle

					finalColorAnimate.setAttribute(
						"values",
						finalAnimatedColors.join(";"),
					);
					finalColorAnimate.setAttribute("dur", `${rainbowSpeed}s`);
					finalColorAnimate.setAttribute("repeatCount", "indefinite");

					// Store animation reference for hover control
					animations.push(finalColorAnimate);

					finalStop.appendChild(finalColorAnimate);
					gradient.appendChild(finalStop);

					return gradient;
				};

				// Create gradients for each side
				const topGradient = createGradient("top-gradient", true, width);
				const rightGradient = createGradient(
					"right-gradient",
					false,
					height,
				);
				const bottomGradient = createGradient(
					"bottom-gradient",
					true,
					width,
				);
				const leftGradient = createGradient(
					"left-gradient",
					false,
					height,
				);

				defs.appendChild(topGradient);
				defs.appendChild(rightGradient);
				defs.appendChild(bottomGradient);
				defs.appendChild(leftGradient);
				svg.appendChild(defs);

				// Create 4 separate lines for each edge
				// Lines are inset by half the stroke width to stay within bounds
				const offset = strokeWidth / 2;

				// Calculate starting dash offset for each side to ensure corner alignment
				let runningOffset = 0;

				// Top edge
				const topLine = document.createElementNS(svgNS, "line");
				topLine.setAttribute("x1", `${offset}`);
				topLine.setAttribute("y1", `${offset}`);
				topLine.setAttribute("x2", `${width - offset}`);
				topLine.setAttribute("y2", `${offset}`);
				topLine.setAttribute("stroke", "url(#top-gradient)");
				topLine.setAttribute("stroke-width", `${strokeWidth}`);
				topLine.setAttribute(
					"stroke-dasharray",
					`${adjustedDashWidth} ${adjustedDashGap}`,
				);
				topLine.setAttribute("stroke-linecap", "square");
				topLine.setAttribute("stroke-dashoffset", `${runningOffset}`);

				const topAnimate = document.createElementNS(svgNS, "animate");
				topAnimate.setAttribute("attributeName", "stroke-dashoffset");
				topAnimate.setAttribute(
					"from",
					`${adjustedDashWidth + adjustedDashGap + runningOffset}`,
				);
				topAnimate.setAttribute("to", `${runningOffset}`);
				topAnimate.setAttribute("dur", `${dashSpeed}s`);
				topAnimate.setAttribute("repeatCount", "indefinite");

				// Store animation reference for hover control
				animations.push(topAnimate);

				topLine.appendChild(topAnimate);
				svg.appendChild(topLine);

				runningOffset += width - strokeWidth;

				// Right edge
				const rightLine = document.createElementNS(svgNS, "line");
				rightLine.setAttribute("x1", `${width - offset}`);
				rightLine.setAttribute("y1", `${offset}`);
				rightLine.setAttribute("x2", `${width - offset}`);
				rightLine.setAttribute("y2", `${height - offset}`);
				rightLine.setAttribute("stroke", "url(#right-gradient)");
				rightLine.setAttribute("stroke-width", `${strokeWidth}`);
				rightLine.setAttribute(
					"stroke-dasharray",
					`${adjustedDashWidth} ${adjustedDashGap}`,
				);
				rightLine.setAttribute("stroke-linecap", "square");
				rightLine.setAttribute(
					"stroke-dashoffset",
					`${runningOffset % adjustedDashPattern}`,
				);

				const rightAnimate = document.createElementNS(svgNS, "animate");
				rightAnimate.setAttribute("attributeName", "stroke-dashoffset");
				rightAnimate.setAttribute(
					"from",
					`${adjustedDashWidth + adjustedDashGap + (runningOffset % adjustedDashPattern)}`,
				);
				rightAnimate.setAttribute(
					"to",
					`${runningOffset % adjustedDashPattern}`,
				);
				rightAnimate.setAttribute("dur", `${dashSpeed}s`);
				rightAnimate.setAttribute("repeatCount", "indefinite");

				// Store animation reference for hover control
				animations.push(rightAnimate);

				rightLine.appendChild(rightAnimate);
				svg.appendChild(rightLine);

				runningOffset += height - strokeWidth;

				// Bottom edge
				const bottomLine = document.createElementNS(svgNS, "line");
				bottomLine.setAttribute("x1", `${width - offset}`);
				bottomLine.setAttribute("y1", `${height - offset}`);
				bottomLine.setAttribute("x2", `${offset}`);
				bottomLine.setAttribute("y2", `${height - offset}`);
				bottomLine.setAttribute("stroke", "url(#bottom-gradient)");
				bottomLine.setAttribute("stroke-width", `${strokeWidth}`);
				bottomLine.setAttribute(
					"stroke-dasharray",
					`${adjustedDashWidth} ${adjustedDashGap}`,
				);
				bottomLine.setAttribute("stroke-linecap", "square");
				bottomLine.setAttribute(
					"stroke-dashoffset",
					`${runningOffset % adjustedDashPattern}`,
				);

				const bottomAnimate = document.createElementNS(
					svgNS,
					"animate",
				);
				bottomAnimate.setAttribute(
					"attributeName",
					"stroke-dashoffset",
				);
				bottomAnimate.setAttribute(
					"from",
					`${adjustedDashWidth + adjustedDashGap + (runningOffset % adjustedDashPattern)}`,
				);
				bottomAnimate.setAttribute(
					"to",
					`${runningOffset % adjustedDashPattern}`,
				);
				bottomAnimate.setAttribute("dur", `${dashSpeed}s`);
				bottomAnimate.setAttribute("repeatCount", "indefinite");

				// Store animation reference for hover control
				animations.push(bottomAnimate);

				bottomLine.appendChild(bottomAnimate);
				svg.appendChild(bottomLine);

				runningOffset += width - strokeWidth;

				// Left edge
				const leftLine = document.createElementNS(svgNS, "line");
				leftLine.setAttribute("x1", `${offset}`);
				leftLine.setAttribute("y1", `${height - offset}`);
				leftLine.setAttribute("x2", `${offset}`);
				leftLine.setAttribute("y2", `${offset}`);
				leftLine.setAttribute("stroke", "url(#left-gradient)");
				leftLine.setAttribute("stroke-width", `${strokeWidth}`);
				leftLine.setAttribute(
					"stroke-dasharray",
					`${adjustedDashWidth} ${adjustedDashGap}`,
				);
				leftLine.setAttribute("stroke-linecap", "square");
				leftLine.setAttribute(
					"stroke-dashoffset",
					`${runningOffset % adjustedDashPattern}`,
				);

				const leftAnimate = document.createElementNS(svgNS, "animate");
				leftAnimate.setAttribute("attributeName", "stroke-dashoffset");
				leftAnimate.setAttribute(
					"from",
					`${adjustedDashWidth + adjustedDashGap + (runningOffset % adjustedDashPattern)}`,
				);
				leftAnimate.setAttribute(
					"to",
					`${runningOffset % adjustedDashPattern}`,
				);
				leftAnimate.setAttribute("dur", `${dashSpeed}s`);
				leftAnimate.setAttribute("repeatCount", "indefinite");

				// Store animation reference for hover control
				animations.push(leftAnimate);

				leftLine.appendChild(leftAnimate);
				svg.appendChild(leftLine);
			};

			// Function to update animation speeds
			const updateAnimationSpeeds = (
				newRainbowSpeed: number,
				newDashSpeed: number,
			) => {
				animations.forEach((animation) => {
					const attributeName =
						animation.getAttribute("attributeName");
					if (attributeName === "stop-color") {
						animation.setAttribute("dur", `${newRainbowSpeed}s`);
					} else if (attributeName === "stroke-dashoffset") {
						animation.setAttribute("dur", `${newDashSpeed}s`);
					}
				});
			};

			// Track pseudo-class states
			let isHovered = false;
			let isFocused = false;
			let isActive = false;

			// Function to determine if any pseudo-class is active and update speeds accordingly
			const updateBorderState = () => {
				if (isHovered || isFocused || isActive) {
					updateAnimationSpeeds(hoverRainbowSpeed, hoverDashSpeed);
				} else {
					updateAnimationSpeeds(rainbowSpeed, dashSpeed);
				}
			};

			// Mouse hover event listeners
			const handleMouseEnter = () => {
				isHovered = true;
				updateBorderState();
			};

			const handleMouseLeave = () => {
				isHovered = false;
				updateBorderState();
			};

			// Focus event listeners
			const handleFocus = () => {
				isFocused = true;
				updateBorderState();
			};

			const handleBlur = () => {
				isFocused = false;
				updateBorderState();
			};

			// Active state event listeners
			const handleMouseDown = () => {
				isActive = true;
				updateBorderState();
			};

			const handleMouseUp = () => {
				isActive = false;
				updateBorderState();
			};

			// Add all event listeners
			element.addEventListener("mouseenter", handleMouseEnter);
			element.addEventListener("mouseleave", handleMouseLeave);
			element.addEventListener("focus", handleFocus);
			element.addEventListener("blur", handleBlur);
			element.addEventListener("mousedown", handleMouseDown);
			element.addEventListener("mouseup", handleMouseUp);
			
			// Also handle mouseup outside the element to reset active state
			document.addEventListener("mouseup", handleMouseUp);

			// Initial render
			updateBorder();

			// Observe resizing
			const resizeObserver = new ResizeObserver(() => {
				updateBorder();
			});
			resizeObserver.observe(element);

			// Return cleanup function
			return () => {
				element.removeEventListener("mouseenter", handleMouseEnter);
				element.removeEventListener("mouseleave", handleMouseLeave);
				element.removeEventListener("focus", handleFocus);
				element.removeEventListener("blur", handleBlur);
				element.removeEventListener("mousedown", handleMouseDown);
				element.removeEventListener("mouseup", handleMouseUp);
				document.removeEventListener("mouseup", handleMouseUp);
				resizeObserver.disconnect();
				const svg = element.querySelector(".rainbow-border-svg");
				if (svg) svg.remove();
			};
		}

		document.addEventListener("DOMContentLoaded", () => {
			const grid = document.querySelector(
				"#grid-container",
			) as HTMLElement;
			const loadingSkeleton = document.querySelector(
				"#loading-skeleton",
			) as HTMLElement;

			if (!grid) return;

			// Handle project card expansion and collapse
			async function handleProjectExpansion(item: HTMLElement) {
				const isExpanded = item.classList.contains("is-expanded");
				const isLoading = item.classList.contains("is-loading");
				const contentDiv = item.querySelector(
					".project-content",
				) as HTMLElement;
				const toggleIcon = item.querySelector(
					".toggle-icon",
				) as HTMLElement;
				const loadingIcon = item.querySelector(
					".loading-icon",
				) as HTMLElement;
				const expandButton = item.querySelector(
					".expand-toggle",
				) as HTMLButtonElement;

				// Prevent interaction during loading
				if (isLoading) return;

				if (!isExpanded) {
					// Load content if needed
					const projectTitle = item.dataset.projectTitle;
					if (!projectTitle || !demos[projectTitle]) return;

					// --- START LOADING ---
					item.classList.add("is-loading");
					expandButton.disabled = true;
					toggleIcon.classList.add("hidden");
					loadingIcon.classList.remove("hidden");

					try {
						const demoContainer = item.querySelector(
							".project-demo-container",
						) as HTMLElement;

						// Call the appropriate demo loader once
						const result = await demos[projectTitle](
							demoContainer,
							item,
						);
						demos[projectTitle] = () => result;

						// --- END LOADING & EXPAND ---
						item.classList.remove("is-loading");
						expandButton.disabled = false;
						loadingIcon.classList.add("hidden");

						// Show the content
						contentDiv.classList.remove("hidden");

						// Update UI
						toggleIcon.textContent = "‚àí";
						toggleIcon.classList.remove("hidden");

						// Add expanded class
						item.classList.add("is-expanded");

						// ResizeObserver will automatically detect the expansion and trigger relayout
						// Keep a small timeout to ensure content is rendered before observation
						setTimeout(() => {
							// Force a size check by updating the dataset
							if (item.dataset.prevHeight) {
								delete item.dataset.prevHeight;
							}
						}, 50);
					} catch (error) {
						// --- ERROR HANDLING ---
						console.error("Failed to load demo:", error);
						item.classList.remove("is-loading");
						expandButton.disabled = false;
						loadingIcon.classList.add("hidden");
						toggleIcon.classList.remove("hidden");
					}
				} else {
					// --- COLLAPSE ---
					// Hide content first
					contentDiv.classList.add("hidden");

					// Update UI
					toggleIcon.textContent = "+";

					// Remove expanded class after a brief delay to allow content to hide
					setTimeout(() => {
						item.classList.remove("is-expanded");

						// ResizeObserver will automatically detect the collapse and trigger relayout
						// Force a size check by updating the dataset
						if (item.dataset.prevHeight) {
							delete item.dataset.prevHeight;
						}
					}, 100);
				}
			}

			// Initialize ResizeObserver for automatic relayout
			const initResizeObserver = () => {
				if (!window.ResizeObserver) {
					console.warn("ResizeObserver not supported");
					return;
				}

				let debounceTimeout: ReturnType<typeof setTimeout>;

				resizeObserver = new ResizeObserver((entries) => {
					if (!pckry) return;

					// Debounce the relayout to avoid excessive calls
					clearTimeout(debounceTimeout);
					debounceTimeout = setTimeout(() => {
						// Check if any observed element has actually changed size
						let shouldRelayout = false;
						for (const entry of entries) {
							const element = entry.target as HTMLElement;
							const gridItem = element.closest(
								".grid-item",
							) as HTMLElement;

							if (gridItem) {
								// Store previous size for comparison
								const prevHeight = gridItem.dataset.prevHeight;
								const currentHeight =
									entry.contentRect.height.toString();

								if (prevHeight !== currentHeight) {
									gridItem.dataset.prevHeight = currentHeight;
									shouldRelayout = true;
								}
							}
						}

						if (shouldRelayout) {
							pckry.layout();
						}
					}, 100);
				});

				// Observe all grid items and their content
				const gridItems = grid.querySelectorAll(".grid-item");
				gridItems.forEach((item) => {
					resizeObserver?.observe(item);
				});
			};

			// Initialize Packery
			const initPackery = () => {
				loadingSkeleton.style.display = "none";
				// @ts-ignore
				window.skeletonPackery.destroy();

				// @ts-ignore
				pckry = new (window.Packery as any)(grid, {
					itemSelector: ".grid-item",
					sizer: ".grid-sizer",
					gutter: 16,
					percentPosition: true,
				});

				// Use event delegation for expand/collapse clicks
				grid.addEventListener("click", (event) => {
					const target = event.target as HTMLElement;
					const button = target.closest(
						".expand-toggle",
					) as HTMLButtonElement;
					if (button && !button.disabled) {
						const item = target.closest(
							".grid-item",
						) as HTMLElement;
						if (item && !item.classList.contains("is-loading")) {
							handleProjectExpansion(item);
						}
					}
				});

				// Initialize ResizeObserver after Packery is ready
				initResizeObserver();

				// Better transition: fade in grid while skeleton is still visible
				grid.style.opacity = "1";

				const newProjectCard = grid.querySelector(
					"[data-project-title='new-project'] > a",
				) as HTMLElement;
				applyRainbowPatternBorder(newProjectCard, {
					dashWidth: 4,
					dashGap: 8,
					strokeWidth: 2,
					dashSpeed: 1,
					rainbowSpeed: 2,
					hoverRainbowSpeed: 1,
				});
			};

			// Cleanup function for when the page is unloaded
			const cleanup = () => {
				if (resizeObserver) {
					resizeObserver.disconnect();
					resizeObserver = null;
				}
			};

			// Add cleanup listener
			window.addEventListener("beforeunload", cleanup);

			// Wait for images to load before initializing to prevent overlap
			initPackery();
		});
	</script>

	<style>
		/* Set the font for the description text */
		.description-text {
			font-family: Times, serif;
		}

		/* Skeleton loading styles */
		@keyframes shimmer {
			0% {
				background-position: -200px 0;
			}
			100% {
				background-position: calc(200px + 100%) 0;
			}
		}

		.skeleton-card {
			background: linear-gradient(
				90deg,
				transparent,
				rgba(255, 255, 255, 0.05),
				transparent
			);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			/* min-height: 200px; */
		}

		.skeleton-title {
			height: 32px;
			width: 60%;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 4px;
		}

		.skeleton-button {
			height: 24px;
			width: 24px;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 4px;
		}

		.skeleton-description {
			height: 18px;
			width: 85%;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 4px;
		}

		.skeleton-description-line {
			height: 18px;
			width: 65%;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 4px;
		}

		.skeleton-tag {
			height: 24px;
			width: 80px;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 12px;
		}

		/* New project skeleton styles - centered layout */
		.skeleton-icon {
			height: 48px;
			width: 48px;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 50%;
			margin: 0 auto;
		}

		.skeleton-title-centered {
			height: 32px;
			width: 200px;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 4px;
			margin: 0 auto;
		}

		.skeleton-description-centered {
			height: 18px;
			width: 250px;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 4px;
			margin: 0 auto;
		}

		.skeleton-description-line-centered {
			height: 18px;
			width: 180px;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 4px;
			margin: 0 auto;
		}

		/* Skeleton container styles */
		#loading-skeleton {
			transition: opacity 0.3s ease-in-out;
			width: 100%;
		}

		/* Base styles for the grid container and items */
		#grid-container {
			position: relative;
		}

		.grid-item {
			box-sizing: border-box;
			width: 100%; /* Full width on mobile */
		}

		.grid-sizer {
			width: 100%;
		}

		/* 2-column layout for medium screens and up */
		@media (min-width: 768px) {
			.grid-item {
				width: calc(50% - 8px);
			}
			.grid-sizer {
				width: calc(50% - 8px);
			}
		}

		/* Style for expanded items */
		.grid-item.is-expanded {
			width: 100% !important; /* Force full width on all screen sizes */
			z-index: 10;
		}

		/* Ensure collapsed items reset to proper width */
		.grid-item:not(.is-expanded) {
			width: 100%; /* Full width on mobile */
		}

		@media (min-width: 768px) {
			.grid-item:not(.is-expanded) {
				width: calc(50% - 8px) !important;
			}
		}

		.project-demo-container {
			display: flex;

			.cm-editor {
				width: 100%;
			}
		}

		/* Ensure project content transitions smoothly */
		.project-content {
			transition: all 0.3s ease;
			overflow: hidden;
		}

		.project-content.hidden {
			max-height: 0;
			opacity: 0;
			margin-top: 0;
			padding-top: 0;
			border-top: none;
		}

		.project-content:not(.hidden) {
			max-height: none;
			opacity: 1;
		}

		.new-project-card {
			&:hover,
			&:focus,
			&:active {
				border: none;
			}
		}

		/* Hover effects for work items */
		.work-item-card {
			position: relative;
		}

		.work-item-card:hover *,
		.work-item-card:active * {
			color: #000000;
			opacity: 1;
		}
		.work-item-card:hover .work-item-tag,
		.work-item-card:active .work-item-tag {
			color: #000000;
			background-color: #f0f0f0;
			border-color: #cccccc;
			opacity: 1;
		}
		/* Loading state styles */
		.expand-toggle:disabled {
			cursor: not-allowed;
			opacity: 0.7;
		}

		/* Perfect centering for toggle button icons */
		.expand-toggle {
			min-width: 24px;
			min-height: 24px;
		}
		.toggle-icon {
			cursor: pointer;
		}

		.toggle-icon,
		.loading-icon {
			display: flex;
			align-items: center;
			justify-content: center;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			transition: opacity 0.2s ease-in-out;
		}

		/* Ensure hidden class works properly with absolute positioning */
		.loading-icon.hidden {
			display: none !important;
		}

		.toggle-icon.hidden {
			display: none !important;
		}

		.loading-icon svg {
			animation: spin 1s linear infinite;
		}

		@keyframes spin {
			from {
				transform: rotate(0deg);
			}
			to {
				transform: rotate(360deg);
			}
		}

		/* Pulsing background animation for loading state - applied as overlay */
		.grid-item.is-loading .work-item-card::before {
			content: "";
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: linear-gradient(
				90deg,
				transparent,
				rgba(255, 255, 255, 0.05),
				transparent
			);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			pointer-events: none;
			z-index: 1;
		}

		/* Ensure content stays above the loading overlay */
		.grid-item.is-loading .work-item-card > * {
			position: relative;
			z-index: 2;
		}

		/* Prevent interaction during loading */
		.grid-item.is-loading .expand-toggle {
			pointer-events: none;
		}

		.grid-item.is-loading {
			opacity: 0.9;
		}
	</style>
</Layout>
