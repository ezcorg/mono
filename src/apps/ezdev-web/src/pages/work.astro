---
import Layout from '../layouts/Layout.astro';
import Footer from '../components/Footer.astro';
import Navbar from '../components/Navbar.astro';
// @ts-expect-error
import Packery from './packery.min.js?raw';

import '../styles/markdown.css';

// Inline Packery script to avoid FOUC, sure would be nice if browser supported Masonry grid natively
const packeryLoad =
	"<script type='module'>" + Packery + ';window.PackeryInit()</script>';
const projects = [
	{
		title: 'markdown-editor',
		description: 'An intuitive, minimal, and feature-rich markdown editor',
		tags: ['TipTap', 'ProseMirror', 'TypeScript'],
		link: 'https://github.com/ezdevlol/mono/tree/main/src/typescript/markdown-editor',
	},
	{
		title: 'codeblock',
		description:
			'A codeblock editor with language server and virtual filesystem support',
		tags: ['CodeMirror', 'TypeScript'],
		link: 'https://github.com/ezdevlol/mono/tree/main/src/typescript/codeblock',
	},
];
---

<!-- Order is sequential, first we make the promise available to the window -->
<script is:inline>
	window.PackeryPromise = new Promise((resolve) => {
		window.PackeryInit = () => {
			resolve(window.Packery);
		};
	});
</script>
<!-- And then resolve it in our Fragment, which is our embedded Packery script -->
<Fragment set:html={packeryLoad} />
<!-- Then, as soon as our skeleton element is available, we use Packery to layout the skeleton -->
<script is:inline>
	function waitForElm(selector) {
		return new Promise((resolve) => {
			if (document.querySelector(selector)) {
				return resolve(document.querySelector(selector));
			}

			const observer = new MutationObserver((mutations) => {
				if (document.querySelector(selector)) {
					observer.disconnect();
					resolve(document.querySelector(selector));
				}
			});

			// If you get "parameter 1 is not of type 'Node'" error, see https://stackoverflow.com/a/77855838/492336
			observer.observe(document.documentElement, {
				childList: true,
				subtree: true,
			});
		});
	}

	waitForElm('#loading-skeleton').then(async (loadingSkeleton) => {
		await window.PackeryPromise;

		window.skeletonPackery = new window.Packery(loadingSkeleton, {
			itemSelector: '.grid-item',
			sizer: '.grid-sizer',
			gutter: 16,
			percentPosition: true,
		});
	});
</script>

<Layout
	title="Work | ez dev"
	description="A showcase of projects we've built for clients around the world."
>
	<section
		class="w-[min(80ch,100vw)] min-h-screen mt-[8rem] flex items-start justify-center px-4 md:px-8"
	>
		<div class="w-full mx-auto flex flex-col gap-8">
			<Navbar currentPath="/work" />

			{/* Loading skeleton placeholders - using same grid structure */}
			<div id="loading-skeleton" class="opacity-100">
				<div class="grid-sizer"></div>
				{
					projects.map((_, index) => (
						<div class="grid-item skeleton-item">
							<div class="skeleton-card border-2 border-[#333333] overflow-hidden">
								<div class="p-6">
									<div class="flex items-center justify-between mb-3">
										<div class="skeleton-title" />
										<div class="skeleton-button" />
									</div>
									<div class="skeleton-description mb-4" />
									<div class="skeleton-description-line mb-4" />
									<div class="flex flex-wrap gap-2 mb-4">
										<div class="skeleton-tag" />
										<div class="skeleton-tag" />
										<div class="skeleton-tag" />
									</div>
								</div>
							</div>
						</div>
					))
				}
			</div>

			{/* Packery Grid Container - positioned over skeleton */}
			<div
				id="grid-container"
				class="opacity-0 absolute top-0 left-0 w-full"
			>
				<div class="grid-sizer"></div>

				{
					projects.map((project) => (
						<div
							class="grid-item"
							data-project-title={project.title}
						>
							<div class="work-item-card h-full border-2 border-[#333333] hover:border-[#ffffff] hover:bg-[#ffffff] transition-all duration-300 overflow-hidden">
								<div class="p-6">
									<div class="flex items-center justify-between mb-3">
										<h3 class="text-2xl font-bold text-[#F5F5F5] work-item-title">
											{project.title}
										</h3>
										<button
											class="expand-toggle text-[#F5F5F5] text-xl transition-transform duration-300"
											aria-label="Toggle project details"
										>
											<span class="toggle-icon">+</span>
										</button>
									</div>
									<p class="description-text text-[18px] text-[#F5F5F5] opacity-80 mb-4 work-item-description">
										{project.description}
									</p>
									<div class="flex flex-wrap gap-2 mb-4">
										{project.tags.map((tech) => (
											<span class="px-2 py-1 text-xs rounded-full border border-[#333333] text-[#F5F5F5] opacity-70 work-item-tag">
												{tech}
											</span>
										))}
									</div>
									<div class="project-content hidden mt-6">
										<div class="project-demo-container min-h-[400px] border border-[#333333]" />
									</div>
								</div>
							</div>
						</div>
					))
				}
			</div>

			{/* Bottom content - initially hidden */}
			<div
				id="bottom-content"
				class="mb-24 px-2 opacity-0 transition-opacity duration-400"
			>
				<p class="text-lg text-[#F5F5F5] opacity-70 mb-8">
					Want to see yours here?
				</p>
				<a
					href="/newproject"
					class="inline-block bg-[#F5F5F5] text-black px-8 py-4 text-lg transition-all duration-300 hover:bg-opacity-90"
				>
					Start a project
				</a>
			</div>
		</div>
	</section>

	<Footer slot="footer" />

	<script>
		import { CodeblockFS } from '@ezdevlol/codeblock';
		import { files } from './data/work.js';

		let pckry: any | null = null;
		let resizeObserver: ResizeObserver | null = null;

		let fs: any = null;

		let initPromise: Promise<void> | null = null;

		async function init() {
			if (initPromise) return initPromise;

			initPromise = (async () => {
				fs = await CodeblockFS.worker();
				await Promise.all(
					files.map(async ([path, content]) => {
						await fs.writeFile(path, content);
					}),
				);
			})();

			return initPromise;
		}
		// Initialize filesystem and demos
		init();

		const demos = {
			'markdown-editor': async (containerEl: HTMLElement) => {
				try {
					const { createEditor } = await import(
						'@ezdevlol/markdown-editor'
					);
					// Ensure fs is initialized before using it
					await initPromise;

					createEditor({
						element: containerEl,
						fs: {
							fs,
							filepath: 'hello.md',
						},
					});
				} catch (error) {
					console.error('Failed to load markdown editor:', error);
					containerEl.innerHTML = `<div class="text-red-500">Failed to load editor (see console for log).</div>`;
				}
			},
			codeblock: async (containerEl: HTMLElement) => {
				try {
					const { createCodeblock, SearchIndex } = await import(
						'@ezdevlol/codeblock'
					);

					// Ensure fs is initialized before using it
					await initPromise;

					const index = await SearchIndex.get(
						fs,
						'.codeblock/index.json',
					);
					createCodeblock({
						parent: containerEl,
						fs,
						filepath: 'example.ts',
						index,
					});
				} catch (error) {
					console.error('Failed to load codeblock editor:', error);
					containerEl.innerHTML = `<div class="text-red-500">Failed to load editor (see console for log).</div>`;
				}
			},
		};

		document.addEventListener('DOMContentLoaded', () => {
			const grid = document.querySelector(
				'#grid-container',
			) as HTMLElement;
			const loadingSkeleton = document.querySelector(
				'#loading-skeleton',
			) as HTMLElement;
			const bottomContent = document.querySelector(
				'#bottom-content',
			) as HTMLElement;

			if (!grid) return;

			// Handle project card expansion and collapse
			async function handleProjectExpansion(item: HTMLElement) {
				const isExpanded = item.classList.contains('is-expanded');
				const contentDiv = item.querySelector(
					'.project-content',
				) as HTMLElement;
				const toggleIcon = item.querySelector(
					'.toggle-icon',
				) as HTMLElement;

				if (!isExpanded) {
					// Load content if needed
					const projectTitle = item.dataset.projectTitle;
					if (!projectTitle || !demos[projectTitle]) return;

					const demoContainer = item.querySelector(
						'.project-demo-container',
					) as HTMLElement;

					// Call the appropriate demo loader once
					const result = await demos[projectTitle](demoContainer);
					demos[projectTitle] = () => result;

					// --- EXPAND ---
					// Show the content
					contentDiv.classList.remove('hidden');

					// Update UI
					toggleIcon.textContent = 'âˆ’';
					toggleIcon.style.transform = 'rotate(180deg)';

					// Add expanded class
					item.classList.add('is-expanded');

					// ResizeObserver will automatically detect the expansion and trigger relayout
					// Keep a small timeout to ensure content is rendered before observation
					setTimeout(() => {
						// Force a size check by updating the dataset
						if (item.dataset.prevHeight) {
							delete item.dataset.prevHeight;
						}
					}, 50);
				} else {
					// --- COLLAPSE ---
					// Hide content first
					contentDiv.classList.add('hidden');

					// Update UI
					toggleIcon.textContent = '+';
					toggleIcon.style.transform = 'rotate(0deg)';

					// Remove expanded class after a brief delay to allow content to hide
					setTimeout(() => {
						item.classList.remove('is-expanded');

						// ResizeObserver will automatically detect the collapse and trigger relayout
						// Force a size check by updating the dataset
						if (item.dataset.prevHeight) {
							delete item.dataset.prevHeight;
						}
					}, 100);
				}
			}

			// Initialize ResizeObserver for automatic relayout
			const initResizeObserver = () => {
				if (!window.ResizeObserver) {
					console.warn('ResizeObserver not supported');
					return;
				}

				let debounceTimeout: ReturnType<typeof setTimeout>;

				resizeObserver = new ResizeObserver((entries) => {
					if (!pckry) return;

					// Debounce the relayout to avoid excessive calls
					clearTimeout(debounceTimeout);
					debounceTimeout = setTimeout(() => {
						// Check if any observed element has actually changed size
						let shouldRelayout = false;
						for (const entry of entries) {
							const element = entry.target as HTMLElement;
							const gridItem = element.closest(
								'.grid-item',
							) as HTMLElement;

							if (gridItem) {
								// Store previous size for comparison
								const prevHeight = gridItem.dataset.prevHeight;
								const currentHeight =
									entry.contentRect.height.toString();

								if (prevHeight !== currentHeight) {
									gridItem.dataset.prevHeight = currentHeight;
									shouldRelayout = true;
								}
							}
						}

						if (shouldRelayout) {
							pckry.layout();
						}
					}, 100);
				});

				// Observe all grid items and their content
				const gridItems = grid.querySelectorAll('.grid-item');
				gridItems.forEach((item) => {
					resizeObserver?.observe(item);
				});
			};

			// Initialize Packery
			const initPackery = () => {
				loadingSkeleton.style.display = 'none';
				// @ts-ignore
				window.skeletonPackery.destroy();

				// @ts-ignore
				pckry = new (window.Packery as any)(grid, {
					itemSelector: '.grid-item',
					sizer: '.grid-sizer',
					gutter: 16,
					percentPosition: true,
				});

				// Use event delegation for expand/collapse clicks
				grid.addEventListener('click', (event) => {
					const target = event.target as HTMLElement;
					const button = target.closest('.expand-toggle');
					if (button) {
						const item = target.closest(
							'.grid-item',
						) as HTMLElement;
						if (item) {
							handleProjectExpansion(item);
						}
					}
				});

				// Initialize ResizeObserver after Packery is ready
				initResizeObserver();

				// Better transition: fade in grid while skeleton is still visible
				grid.style.opacity = '1';

				// After grid is visible, fade out skeleton and show bottom content
				setTimeout(() => {
					bottomContent.style.opacity = '1';
				}, 200);
			};

			// Cleanup function for when the page is unloaded
			const cleanup = () => {
				if (resizeObserver) {
					resizeObserver.disconnect();
					resizeObserver = null;
				}
			};

			// Add cleanup listener
			window.addEventListener('beforeunload', cleanup);

			// Wait for images to load before initializing to prevent overlap
			initPackery();
		});
	</script>

	<style>
		/* Set the font for the description text */
		.description-text {
			font-family: Times, serif;
		}

		/* Skeleton loading styles */
		@keyframes shimmer {
			0% {
				background-position: -200px 0;
			}
			100% {
				background-position: calc(200px + 100%) 0;
			}
		}

		.skeleton-card {
			background: linear-gradient(
				90deg,
				transparent,
				rgba(255, 255, 255, 0.05),
				transparent
			);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			/* min-height: 200px; */
		}

		.skeleton-title {
			height: 32px;
			width: 60%;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 4px;
		}

		.skeleton-button {
			height: 24px;
			width: 24px;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 4px;
		}

		.skeleton-description {
			height: 18px;
			width: 85%;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 4px;
		}

		.skeleton-description-line {
			height: 18px;
			width: 65%;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 4px;
		}

		.skeleton-tag {
			height: 24px;
			width: 80px;
			background: linear-gradient(90deg, #333333, #444444, #333333);
			background-size: 200px 100%;
			animation: shimmer 1.5s ease-in-out infinite;
			border-radius: 12px;
		}

		/* Skeleton container styles */
		#loading-skeleton {
			transition: opacity 0.3s ease-in-out;
		}

		/* Base styles for the grid container and items */
		#grid-container {
			position: relative;
		}

		#bottom-content {
			transition: opacity 0.4s ease-in-out;
		}
		.grid-item {
			box-sizing: border-box;
			width: 100%; /* Full width on mobile */
		}
		.grid-sizer {
			width: 100%;
		}

		/* 2-column layout for medium screens and up */
		@media (min-width: 768px) {
			.grid-item {
				width: calc(50% - 8px);
			}
			.grid-sizer {
				width: calc(50% - 8px);
			}
		}

		/* Style for expanded items */
		.grid-item.is-expanded {
			width: 100% !important; /* Force full width on all screen sizes */
			z-index: 10;
		}

		/* Ensure collapsed items reset to proper width */
		.grid-item:not(.is-expanded) {
			width: 100%; /* Full width on mobile */
		}

		@media (min-width: 768px) {
			.grid-item:not(.is-expanded) {
				width: calc(50% - 8px) !important;
			}
		}

		.project-demo-container {
			display: flex;

			.cm-editor {
				width: 100%;
			}
		}

		/* Ensure project content transitions smoothly */
		.project-content {
			transition: all 0.3s ease;
			overflow: hidden;
		}

		.project-content.hidden {
			max-height: 0;
			opacity: 0;
			margin-top: 0;
			padding-top: 0;
			border-top: none;
		}

		.project-content:not(.hidden) {
			max-height: none;
			opacity: 1;
		}

		/* Hover effects for work items */
		.work-item-card {
			box-shadow: 0 0 0 rgba(255, 255, 255, 0);
		}
		.work-item-card:hover {
			box-shadow: 0 0 25px rgba(255, 255, 255, 0.4);
		}

		.work-item-card:hover * {
			color: #000000;
			opacity: 1;
		}
		.work-item-card:hover .work-item-tag {
			color: #000000;
			background-color: #f0f0f0;
			border-color: #cccccc;
			opacity: 1;
		}
	</style>
</Layout>
